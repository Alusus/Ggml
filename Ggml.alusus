import "Srl/Array.alusus";
import "Srl/String.alusus";
import "Apm";
Apm.importFile("Alusus/Sle", { "Srl/enums.alusus" });

import "Bin/libggml-base.so.0.9.5";
import "Bin/libggml.so.0.9.5";
import "Bin/libggml-cpu-x64.so";
CharsPtr(Srl.System.getEnv("GGML_USE_VULKAN")).{
    if this != 0 and Srl.String.isEqual(this, "1") {
        Core.importFile("Bin/libggml-vulkan.so");
    }
};

import "Ggml/ThreadPool";
import "Ggml/Tensor";
import "Ggml/CPlan";
import "Ggml/CGraph";
import "Ggml/Context";
import "Ggml/Backend";
import "Ggml/BackendBuffer";
import "Ggml/Gallocr";

@merge module Ggml {
    class Status {
        Srl.setupIntEnum[];
        Srl.enumIntValue[ALLOC_FAILED, -2i32];
        Srl.enumIntValue[FAILED, -1i32];
        Srl.enumIntValue[SUCCESS, 0i32];
        Srl.enumIntValue[ABORTED, 1i32];
    }

    class Type {
        Srl.setupIntEnum[];
        Srl.enumIntValue[F32, 0i32];
        Srl.enumIntValue[F16, 1i32];
        Srl.enumIntValue[Q4_0, 2i32];
        Srl.enumIntValue[Q4_1, 3i32];
        Srl.enumIntValue[Q5_0, 6i32];
        Srl.enumIntValue[Q5_1, 7i32];
        Srl.enumIntValue[Q8_0, 8i32];
        Srl.enumIntValue[Q8_1, 9i32];
        Srl.enumIntValue[Q2_K, 10i32];
        Srl.enumIntValue[Q3_K, 11i32];
        Srl.enumIntValue[Q4_K, 12i32];
        Srl.enumIntValue[Q5_K, 13i32];
        Srl.enumIntValue[Q6_K, 14i32];
        Srl.enumIntValue[IQ2_XXS, 16i32];
        Srl.enumIntValue[IQ2_XS, 17i32];
        Srl.enumIntValue[IQ3_XXS, 18i32];
        Srl.enumIntValue[IQ1_S, 19i32];
        Srl.enumIntValue[IQ4_NL, 20i32];
        Srl.enumIntValue[IQ3_S, 21i32];
        Srl.enumIntValue[IQ2_S, 22i32];
        Srl.enumIntValue[IQ4_XS, 23i32];
        Srl.enumIntValue[I8, 24i32];
        Srl.enumIntValue[I16, 25i32];
        Srl.enumIntValue[I32, 26i32];
        Srl.enumIntValue[I64, 27i32];
        Srl.enumIntValue[F64, 28i32];
        Srl.enumIntValue[IQ1_M, 29i32];
        Srl.enumIntValue[BF16, 30i32];
    }

    class FType {
        Srl.setupIntEnum[];
        Srl.enumIntValue[UNKNOWN, -1i32];
        Srl.enumIntValue[ALL_F32, 0i32];
        Srl.enumIntValue[MOSTLY_F16, 1i32];
        Srl.enumIntValue[MOSTLY_Q4_0, 2i32];
        Srl.enumIntValue[MOSTLY_Q4_1, 3i32];
        Srl.enumIntValue[MOSTLY_Q4_1_SOME_F16, 4i32];
        Srl.enumIntValue[MOSTLY_Q8_0, 7i32];
        Srl.enumIntValue[MOSTLY_Q5_0, 8i32];
        Srl.enumIntValue[MOSTLY_Q5_1, 9i32];
        Srl.enumIntValue[MOSTLY_Q2_K, 10i32];
        Srl.enumIntValue[MOSTLY_Q3_K, 11i32];
        Srl.enumIntValue[MOSTLY_Q4_K, 12i32];
        Srl.enumIntValue[MOSTLY_Q5_K, 13i32];
        Srl.enumIntValue[MOSTLY_Q6_K, 14i32];
        Srl.enumIntValue[MOSTLY_IQ2_XXS, 15i32];
        Srl.enumIntValue[MOSTLY_IQ2_XS, 16i32];
        Srl.enumIntValue[MOSTLY_IQ3_XXS, 17i32];
        Srl.enumIntValue[MOSTLY_IQ1_S, 18i32];
        Srl.enumIntValue[MOSTLY_IQ4_NL, 19i32];
        Srl.enumIntValue[MOSTLY_IQ3_S, 20i32];
        Srl.enumIntValue[MOSTLY_IQ2_S, 21i32];
        Srl.enumIntValue[MOSTLY_IQ4_XS, 22i32];
        Srl.enumIntValue[MOSTLY_IQ1_M, 23i32];
        Srl.enumIntValue[MOSTLY_BF16, 24i32];
        Srl.enumIntValue[MOSTLY_MXFP4, 25i32];
    }

    class NumaStrategy {
        Srl.setupIntEnum[];
        Srl.enumIntValue[DISABLED, 0];
        Srl.enumIntValue[DISTRIBUTE, 1];
        Srl.enumIntValue[ISOLATE, 2];
        Srl.enumIntValue[NUMACTL, 3];
        Srl.enumIntValue[MIRROR, 4];
        Srl.enumIntValue[COUNT, 5];
    }

    class InitParams {
        def memSize: ArchWord;
        def memBuffer: ptr;
        def noAlloc: Bool;
    }

    @expname[ggml_init]
    func init(params: InitParams): ref[Context];

    @expname[ggml_free]
    func free(ctx: ref[Context]);

    @expname[ggml_numa_init]
    func _numaInit(numaStrategy: Int);
    func numaInit(numaStrategy: NumaStrategy) {
        _numaInit(numaStrategy.val);
    }

    @expname[ggml_is_numa]
    func isNuma(): Bool;

    @expname[ggml_tensor_overhead]
    func getTensorOverhead(): ArchWord;

    @expname[ggml_type_size]
    func _getTypeSize(type: Int): ArchWord;
    func getTypeSize(type: Type): ArchWord {
        return _getTypeSize(type.val);
    }

    @expname[ggml_row_size]
    func _getRowSize(type: Int, ne: Int[64]): ArchWord;
    func getRowSize(type: Type, ne: Int[64]): ArchWord {
        return _getRowSize(type.val, ne);
    }

    @expname[ggml_graph_overhead]
    func getGraphOverhead(): ArchWord;

    @expname[ggml_set_abort_callback]
    func setAbortCallback(cb: ptr[func (CharsPtr)]): ptr[func (CharsPtr)];

    @expname[ggml_abort]
    func abort(file: CharsPtr, line: Int, fmt: CharsPtr, ...any);

    @expname[ggml_ftype_to_ggml_type]
    func _fTypeToType(ftype: Int): Int;
    func fTypeToType(ftype: FType): Type {
        return Type().{ val = _fTypeToType(ftype.val) };
    }

    @expname[ggml_status_to_string]
    func _statusToString(status: Int): CharsPtr;
    func statusToString(status: Status): CharsPtr {
        return _statusToString(status.val);
    }

    @expname[ggml_fp16_to_fp32]
    func fp16ToFp32(v: Word[16]): Float;

    @expname[ggml_fp16_to_fp32_row]
    func fp16ToFp32(src: ref[array[Word[16]]], dst: ref[array[Float]], len: Int[64]);

    @expname[ggml_fp32_to_fp16]
    func fp32ToFp16(v: Float): Word[16];

    @expname[ggml_fp32_to_fp16_row]
    func fp32ToFp16(src: ref[array[Float]], dst: ref[array[Word[16]]], len: Int[64]);

    @expname[ggml_fp32_to_bf16]
    func fp32ToBf16(v: Float): Word[16];

    @expname[ggml_fp32_to_bf16_row]
    func fp32ToBf16(src: ref[array[Float]], dst: ref[array[Word[16]]], len: Int[64]);

    @expname[ggml_bf16_to_fp32]
    func bf16ToFp32(v: Word[16]): Float;

    @expname[ggml_bf16_to_fp32_row]
    func bf16ToFp32(src: ref[array[Word[16]]], dst: ref[array[Float]], len: Int[64]);

    @expname[ggml_build_forward_expand]
    func buildForwardExpand(graph: ref[CGraph], tensor: ref[Tensor]);

    @expname[ggml_build_backward_expand]
    func buildBackwardExpand(context: ref[Context], graph: ref[CGraph], tensor: ref[ref[Tensor]]);
}
